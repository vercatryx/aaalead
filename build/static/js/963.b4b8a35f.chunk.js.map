{"version":3,"file":"static/js/963.b4b8a35f.chunk.js","mappings":"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","sources":["../node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":["EventStreamSerde","constructor","_ref","marshaller","serializer","deserializer","serdeContext","defaultContentType","_defineProperty","this","serializeEventStream","_ref2","eventStream","requestSchema","initialRequest","eventStreamMember","getEventStreamMember","unionSchema","getMemberSchema","initialRequestMarker","Symbol","eventStreamIterable","asyncIterator","_wrapAsyncGenerator","headers","type","value","write","body","flush","_iteratorError","_iteratorAbruptCompletion","_didIteratorError","_step","_iterator","_asyncIterator","_awaitAsyncGenerator","next","done","page","err","return","serialize","event","_Object$keys$find","unionMember","Object","keys","find","key","additionalHeaders","eventType","explicitPayloadContentType","writeEventBody","_objectSpread","deserializeEventStream","_ref3","_firstEvent$value","response","responseSchema","initialResponseContainer","memberSchemas","getMemberSchemas","initialResponseMarker","asyncIterable","deserialize","async","_Object$keys$find2","dataObject","read","eventStreamSchema","isStructSchema","out","hasBindings","name","member","structIterator","eventHeader","eventPayload","getMergedTraits","Boolean","isBlobSchema","isStringSchema","_this$serdeContext$ut","_this$serdeContext","utf8Encoder","toUtf8","_event$unionMember$he","isNumericSchema","BigInt","toString","Number","$unknown","firstEvent","Error","entries","_firstEvent$value2","_this$serdeContext$ut2","_this$serdeContext2","explicitPayloadMember","getSchema","includes","eventSchema","memberName","memberSchema","isTimestampSchema","isBooleanSchema","payloadSchema","messageSerialization","utf8Decoder","fromUtf8"],"ignoreList":[],"sourceRoot":""}